# 가비지 컬렉션(Garbage Collection)

자바스크립트의 메모리 관리는 자동으로 수행되며 눈에 보이지 않습니다. 원시값, 객체, 함수 등을 만들 때 이 모든 것은 메모리를 차지합니다.

만약 어떤 것이 더는 필요 없어진다면 무슨 일이 발생할까요? 자바스크립트 엔진은 어떻게 필요 없는 것을 찾아내 삭제할까요?

## 도달 가능성(Reachability)

자바스크립트 메모리 관리는 *도달 가능성(Reachability)* 이라는 개념을 바탕으로 수행됩니다.

쉽게 말해, "도달 가능한(reachable)" 값은 어떻게든 접근하거나 사용할 수 있는 값을 말합니다. 이 값은 메모리에 유지되는 것이 보장됩니다.

1. 본질적으로 도달 가능한 값들의 기본 집합이 있습니다. 이 값들은 명백한 이유가 없다면 삭제할 수 없습니다.

    예를 들어:

    - 현재 함수의 지역 변수와 매개 변수
    - 중첩된 함수 호출로 실행된 경우 현재 스코프 체인에 있는 변수와 매개 변수
    - 전역 변수
    - (내부적인 다른 값들도 존재합니다.)

    이 값들은 *루트(roots)* 라고 부릅니다.

2. 루트에서 참조나 참조의 체인에 의해 도달 가능한 값이 있다면 그 값은 도달 가능한 값이 됩니다.

    예를 들어, 만약 지역 변수가 어떤 객체를 참조하고 있고 이 객체는 다른 객체를 참조하는 프로퍼티를 갖고 있다면, 프로퍼티가 참조하는 객체는 도달 가능하다고 여겨집니다. 그리고 그 객체가 참조하는 값들 역시 도달 가능하다고 여겨집니다. 아래에서 자세한 예시를 살펴보도록 합시다.

자바스크립트 엔진에는 [가비지 컬렉터(garbage collector)](https://en.wikipedia.org/wiki/Garbage_collection_(computer_science)) 라는 백그라운드 프로세스가 있습니다. 가비지 컬렉터는 모든 객체를 모니터링하면서 객체가 도달할 수 없는 상태가 되었을 때 삭제합니다.

## 간단한 예제

간단한 예제를 하나 살펴봅시다.:

```js
// user는 객체에 대한 참조를 갖고 있습니다.
let user = {
  name: "John"
};
```

![](memory-user-john.png)

이 그림에서 화살표는 객체 참조를 나타냅니다. 전역 변수(`<global>`) `"user"`는 `{name: "John"}` (줄여서 John이라고 부르겠습니다) 이라는 객체를 참조합니다. John의 `"name"` 프로퍼티는 원시값을 저장하고 있기 때문에 객체(`Object`) 안에 위치합니다.

만약 `user` 값이 다른 값으로 덮어 쓰이면, 기존의 참조는 사라집니다.:

```js
user = null;
```

![](memory-user-john-lost.png)

이제 John은 도달할 수 없게 되었습니다. John에 접근할 방법은 없으며, John에 대한 어떤 참조도 존재하지 않습니다. 가비지 컬렉터는 이 데이터를 삭제하고 메모리를 해제할 것입니다.

## 두 개의 참조

`user`의 참조를 `admin`에 복사했다고 가정해봅시다:

```js
// user는 객체에 대한 참조를 갖고 있습니다.
let user = {
  name: "John"
};

*!*
let admin = user;
*/!*
```

![](memory-user-john-admin.png)

위에서처럼 `user`를 다른 값으로 덮어써 봅시다:
```js
user = null;
```

...객체는 여전히 전역 변수 `admin`을 통해 접근할 수 있으므로, 메모리 안에 남아있습니다. 만약 `admin`을 다른 값으로 덮어쓴다면, 객체는 삭제될 수 있습니다.

## 서로 연결된 객체

이제 더 복잡한 예제, family를 살펴봅시다.:

```js
function marry(man, woman) {
  woman.husband = man;
  man.wife = woman;

  return {
    father: man,
    mother: woman
  }
}

let family = marry({
  name: "John"
}, {
  name: "Ann"
});
```

`marry` 함수는 두 객체를 서로 참조하게 하면서 "결혼"시킵니다. 그다음, 두 객체를 포함한 새로운 객체를 반환합니다.

결과적으로 메모리 구조는 이렇게 됩니다.:

![](family.png)

지금은 모든 객체가 접근 가능한 상태에 있습니다.

이제 두 참조를 지워봅시다.:

```js
delete family.father;
delete family.mother.husband;
```

![](family-delete-refs.png)

참조를 하나만 지웠다면, 모든 객체가 여전히 접근 가능한 상태로 남아있으므로 충분하지 않습니다.

그러나 참조 두 개를 모두 지우면, John에 대한 참조는 더 이상 존재하지 않게 됩니다.:

![](family-no-father.png)

John에서 외부로 나가는 참조는 문제가 되지 않습니다. 외부에서 들어오는 참조만이 객체를 도달 가능한 상태로 만듭니다. 따라서 John은 이제 도달할 수 없게 되었고, 접근 불가능한 John의 데이터는 메모리에서 제거될 것입니다.

가비지 컬렉션 수행 후 결과는 다음과 같습니다.:

![](family-no-father-2.png)

## 도달할 수 없는 섬

서로 연결된 객체들이 만드는 섬에 도달할 수 없는 경우, 이 객체들은 메모리에서 제거됩니다.

근원 객체는 위의 예시에서와 같이 `family`이고, 이 객체가 아무것도 참조하지 않도록 해 봅시다.:

```js
family = null;
```

이제 메모리 내부 상태는 다음과 같아집니다.:

![](family-no-family.png)

도달할 수 없는 섬 예제는 도달 가능성이라는 개념이 얼마나 중요한지 보여줍니다.

John과 Ann은 여전히 연결되어 있고, 둘 다 외부에서 들어오는 참조를 갖고 있습니다. 하지만 이것만으로는 충분하지 않습니다.

 `"family"` 객체와 루트의 연결이 해제되면서 이 객체에 대한 참조가 존재하지 않게 되었고, 섬 전체가 도달할 수 없는 상태가 되어 섬을 구성하는 객체들은 메모리에서 제거될 것입니다.

## 내부 알고리즘

가비지 컬렉션의 기본적인 알고리즘은 "마크 앤 스윕(mark-and-sweep)"이라고 불립니다.

일반적으로 "가비지 컬렉션"은 다음 단계를 거쳐 수행됩니다.:

- 가비지 컬렉터는 루트(root)에 접근하여 그들을 "마크"(기억) 합니다.
- 그리고 루트가 참조하고 있는 모든 것들에 방문하여 "마크" 합니다.
- 이제 마크된 모든 객체에 방문하여 *그들의* 참조에도 마크합니다. 같은 객체를 다시 방문하지 않기 위해 방문한 모든 객체는 기억됩니다.
- ...(루트로부터 도달 가능하며) 방문하지 않은 참조가 있다면 위 과정을 반복 수행합니다.
- 마크되지 않은 모든 객체는 삭제됩니다.

예를 들어 다음과 같은 객체 구조가 있다고 해봅시다.:

![](garbage-collection-1.png)

오른편에 "도달할 수 없는 섬"이 보이네요. 이제 가비지 컬렉터의 "마크 앤 스윕" 알고리즘이 이것을 어떻게 처리하는지 알아봅시다.

첫 번째 단계에선 루트를 마크합니다.:

![](garbage-collection-2.png)

이후 루트가 참조하고 있는 것들을 마크합니다.:

![](garbage-collection-3.png)

...그리고 나서 그것들이 참조하고 있는 것들을 마크합니다. 가능한 범위에서 이 과정을 반복합니다.:

![](garbage-collection-4.png)

이 과정에서 방문할 수 없었던 객체들은 도달 불가능한 것으로 여겨져 메모리에서 삭제됩니다.:

![](garbage-collection-5.png)

이것이 바로 가비지 컬렉션이 작동하는 개념입니다.

자바스크립트 엔진은 실행에 영향을 주지 않으면서 가비지 컬렉션이 빠르게 수행될 수 있도록 다양한 최적화 과정을 거칩니다.

최적화 예시:

- **세대별 수집(Generational collection)** -- 객체를 "새로운 객체"와 "오래된 객체" 두 집합으로 나눕니다. 생성된 다음 제 역할을 다 하고 빠르게 죽는 객체가 많은데, 이 객체들을 공격적으로 제거합니다. 충분한 시간 동안 살아남은 객체들은 "오래된 객체"로 분류해 가비지 컬렉터가 덜 검사하도록 합니다.
- **점진적 수집(Incremental collection)** -- 
객체가 많은 경우에 모든 객체 집합을 한 번에 방문하면 시간이 오래 걸리고, 실행을 눈에 띄게 늦추게 됩니다. 이 때문에 자바스크립트 엔진은 가비지 컬렉션을 여러 부분으로 나눠 수행합니다. 분류한 작업은 하나씩 별도로 수행됩니다. 작업을 나누면서 발생한 변경사항을 추적하기 위해 추가적인 기록이 필요하지만, 이렇게 하면 한 번의 큰 지연 대신 여러 번의 작은 지연을 갖게 됩니다.
- **유휴 시간 수집(Idle-time collection)** -- 가비지 컬렉터는 실행에 끼칠 수 있는 영향을 줄이기 위해 CPU가 유휴 상태일 때에만 실행됩니다.

이외에도 다양한 최적화 기법과 알고리즘이 존재합니다. 최대한 많이 설명하면 좋겠지만 엔진마다 차이가 있고, 다른 기술을 사용하기 때문에 자세한 설명은 여기서 멈추도록 하겠습니다. 중요한 점은 엔진들이 발전함에 따라 모든 것이 변화한다는 것입니다. 그러므로 실제로 필요하지 않은데, "미리" 깊은 내용으로 들어가지 말도록 합시다. 그만한 가치가 없기 때문입니다. 순수한 관심 때문이라면 아래에 있는 링크를 확인해보세요.

## 요약

알아야 하는 핵심 사항은 다음과 같습니다.:

- 가비지 컬렉션은 자동으로 수행됩니다. 개발자가 실행하거나 막을 수 없습니다.
- 객체들은 도달 가능한 상태일 때 메모리에 남습니다.
- 참조된다는 개념과 (루트로부터) 도달 가능하다는 개념은 다릅니다.: 서로 연결된 객체 뭉치도 도달 불가능할 수 있습니다.

현대의 엔진은 더욱 발전된 가비지 컬렉션 알고리즘을 구현합니다.

"The Garbage Collection Handbook: The Art of Automatic Memory Management" (R. Jones et al) 책에서 이와 관련된 전반적인 내용을 다룹니다.

저 수준(low-level)프로그래밍에 익숙하다면, [A tour of V8: Garbage Collection](http://jayconrod.com/posts/55/a-tour-of-v8-garbage-collection)를 통해 V8 가비지 컬렉터에 대한 더욱 자세한 내용을 확인해 보세요.

[V8 블로그](http://v8project.blogspot.com/)엔 메모리 관리의 변화에 대한 글이 종종 게재됩니다. 가비지 컬렉션을 공부하려면 V8의 내부구조를 공부하거나 V8의 엔지니어로 일했던 [Vyacheslav Egorov](http://mrale.ph) 의 블로그를 읽는 것이 좋습니다. 제가 "V8" 엔진을 언급하는 이유는 이 엔진에 대해 잘 설명한 글들을 인터넷에서 읽을 수 있기 때문입니다. 다른 엔진들의 접근법도 V8과 비슷한데, 가비지 컬렉션에는 많은 차이가 있습니다.

저 수준에서의 최적화가 필요한 상황이라면, 엔진에 대한 깊은 지식이 필요합니다. 먼저 자바스크립트에 익숙해진 후에 다음 단계로 나아가는걸 추천해 드립니다.